{"mappings":"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","sources":["src/index.js"],"sourcesContent":["window.addEventListener('load', function () {\n  const canvas = this.document.getElementById('canvas1');\n  const ctx = canvas.getContext('2d');\n  canvas.width = 1280;\n  canvas.height = 720;\n\n  ctx.fillStyle = 'white';\n  ctx.lineWidth = 3;\n  ctx.strokeStyle = 'white';\n\n  class Player {\n    constructor(game) {\n      this.game = game;\n      this.collisionX = this.game.width * 0.5;\n      this.collisionY = this.game.height * 0.5;\n      this.collisionRadius = 30;\n      this.speedX = 0;\n      this.speedY = 0;\n      this.dx = 0;\n      this.dy = 0;\n      this.speedModifier = 20;\n    }\n    draw(context) {\n      context.beginPath();\n      context.arc(\n        this.collisionX,\n        this.collisionY,\n        this.collisionRadius,\n        0,\n        Math.PI * 2\n      );\n      context.save();\n      context.globalAlpha = 0.5;\n      context.fill();\n      context.restore();\n      context.stroke();\n      context.beginPath();\n      context.moveTo(this.collisionX, this.collisionY);\n      context.lineTo(this.game.mouse.x, this.game.mouse.y);\n      context.stroke();\n    }\n    update() {\n      this.dx = this.game.mouse.x - this.collisionX;\n      this.dy = this.game.mouse.y - this.collisionY;\n      const distance = Math.hypot(this.dy, this.dx);\n      if (distance > this.speedModifier) {\n        this.speedX = this.dx / distance || 0;\n        this.speedY = this.dy / distance || 0;\n      } else {\n        this.speedX = 0;\n        this.speedY = 0;\n      }\n      this.collisionX += this.speedX * this.speedModifier;\n      this.collisionY += this.speedY * this.speedModifier;\n      // collision with obstacles\n      this.game.obstacles.forEach(obstacle => {\n        if (this.game.checkCollision(this, obstacle)) {\n          console.log('collision');\n        }\n      });\n    }\n  }\n\n  class Obstacle {\n    constructor(game) {\n      this.game = game;\n      this.collisionX = Math.random() * this.game.width;\n      this.collisionY = Math.random() * this.game.height;\n      this.collisionRadius = 60;\n      this.image = document.getElementById('obstacles');\n      this.spriteWidth = 250;\n      this.spriteHeight = 250;\n      this.width = this.spriteWidth;\n      this.height = this.spriteHeight;\n      this.spriteX = this.collisionX - this.width * 0.5;\n      this.spriteY = this.collisionY - this.height * 0.5 - 70;\n      this.frameX = Math.floor(Math.random() * 4);\n      this.frameY = Math.floor(Math.random() * 3);\n    }\n    draw(context) {\n      context.drawImage(\n        this.image,\n        this.frameX * this.spriteWidth,\n        0 * this.spriteHeight,\n        this.spriteWidth,\n        this.spriteHeight,\n        this.spriteX,\n        this.spriteY,\n        this.width,\n        this.height\n      );\n      context.beginPath();\n      context.arc(\n        this.collisionX,\n        this.collisionY,\n        this.collisionRadius,\n        0,\n        Math.PI * 2\n      );\n      context.save();\n      context.globalAlpha = 0.5;\n      context.fill();\n      context.restore();\n      context.stroke();\n    }\n  }\n\n  class Game {\n    constructor(canvas) {\n      this.canvas = canvas;\n      this.width = this.canvas.width;\n      this.height = this.canvas.height;\n      this.topMargin = 260;\n      this.player = new Player(this);\n      this.numberOfObstacles = 8;\n      this.obstacles = [];\n      this.mouse = {\n        x: this.width * 0.5,\n        y: this.height * 0.5,\n        pressed: false,\n      };\n\n      canvas.addEventListener('mousedown', e => {\n        this.mouse.x = e.offsetX;\n        this.mouse.y = e.offsetY;\n        this.mouse.pressed = true;\n      });\n      canvas.addEventListener('mouseup', e => {\n        this.mouse.x = e.offsetX;\n        this.mouse.y = e.offsetY;\n        this.mouse.pressed = false;\n      });\n      canvas.addEventListener('mousemove', e => {\n        if (this.mouse.pressed) {\n          this.mouse.x = e.offsetX;\n          this.mouse.y = e.offsetY;\n        }\n      });\n    }\n    render(context) {\n      this.player.draw(context);\n      this.player.update();\n      this.obstacles.forEach(obstacle => obstacle.draw(context));\n    }\n    checkCollision(a, b) {\n      const dx = a.collisionX - b.collisionX;\n      const dy = a.collisionY - b.collisionY;\n      const distance = Math.hypot(dy, dx);\n      const sumOfRadii = a.collisionRadius + b.collisionRadius;\n      return distance < sumOfRadii;\n    }\n    init() {\n      let attempts = 0;\n      while (this.obstacles.length < this.numberOfObstacles && attempts < 500) {\n        let testObstacle = new Obstacle(this);\n        let overlap = false;\n        this.obstacles.forEach(obstacle => {\n          const dx = testObstacle.collisionX - obstacle.collisionX;\n          const dy = testObstacle.collisionY - obstacle.collisionY;\n          const distance = Math.hypot(dy, dx);\n          const distanceBuffer = 150;\n          const sumOfRadii =\n            testObstacle.collisionRadius +\n            obstacle.collisionRadius +\n            distanceBuffer;\n          if (distance < sumOfRadii) {\n            overlap = true;\n          }\n        });\n        const margin = testObstacle.collisionRadius * 2;\n        if (\n          !overlap &&\n          testObstacle.spriteX > 0 &&\n          testObstacle.spriteX < this.width - testObstacle.width &&\n          testObstacle.collisionY > this.topMargin + margin &&\n          testObstacle.collisionY < this.height - margin\n        ) {\n          this.obstacles.push(testObstacle);\n        }\n        attempts++;\n      }\n    }\n  }\n\n  const game = new Game(canvas);\n  game.init();\n  console.log(game);\n\n  function animate() {\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    game.render(ctx);\n    requestAnimationFrame(animate);\n  }\n  animate();\n});\n"],"names":["window","addEventListener","canvas","this","document","getElementById","ctx","getContext","width","height","fillStyle","lineWidth","strokeStyle","Player","draw","context","beginPath","arc","collisionX","collisionY","collisionRadius","Math","PI","save","globalAlpha","fill","restore","stroke","moveTo","lineTo","game","mouse","x","y","update","dx","dy","distance","hypot","speedModifier","speedX","speedY","obstacles","forEach","obstacle","checkCollision","console","log","constructor","Obstacle","drawImage","image","frameX","spriteWidth","spriteHeight","spriteX","spriteY","random","floor","frameY","render","player","a","b","init","attempts","length","numberOfObstacles","testObstacle","overlap","margin","topMargin","push","pressed","e","offsetX","offsetY","animate","clearRect","requestAnimationFrame"],"version":3,"file":"index.31ab01c5.js.map"}